/* GpgChecker.c - The GnuPG Signatures Verification Frontend
 *
 * Copyright (C) IvanAegis
 *
 * This file is part of GpgChecker.
 *
 * GpgChecker is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * GpgChecker is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, see <http://www.gnu.org/licenses/>.
 */
#define ISOLATION_AWARE_ENABLED 1
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <commdlg.h>
#include <commctrl.h>
#include <stdio.h>
#include <tchar.h>
#include "resource.h"
#include <string.h>
#include <stdlib.h>

HINSTANCE gInstance=0;

LRESULT CALLBACK MainDialogFunc(HWND hwndDlg,UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    void ResetListView(HWND hListview) {
    ListView_DeleteAllItems(hListview);
    }

    void warnIfFileNotPresent(const char* filename) {
    // Get the full path of the executable
    char exePath[MAX_PATH];
    GetModuleFileName(NULL, exePath, MAX_PATH);

    // Extract the directory path
    char* lastBackslash = strrchr(exePath, '\\');
    if (lastBackslash != NULL)
        *lastBackslash = '\0';

    // Append the file name you want to check
    char filePath[MAX_PATH];
    snprintf(filePath,MAX_PATH, "%s\\%s", exePath, filename);

    // Check if the gpg.exe file exists, close program if not found.
    if (GetFileAttributes(filePath) == INVALID_FILE_ATTRIBUTES) {
        MessageBox(NULL, "GnuPG executable not found\nClosing Program...", "Fatal Error", MB_OK | MB_ICONERROR);
        exit(1);//close the program
    }
}
    
    // Export list view to a CSV file.
    void ExportListViewToFile(HWND hListview, const char* filename) {
    FILE* file = fopen(filename, "w");
    if (!file) {
        MessageBox(NULL, "Failed to open file for writing.", "Error", MB_OK | MB_ICONERROR);
        return;
               }

    int itemCount = ListView_GetItemCount(hListview);
    fprintf(file, "\"Filename\",\"Signature Status\",\"Signature ID\",\"Issuer\"\n");
    for (int i = 0; i < itemCount; ++i) {
        char buffer[260];
        for (int col = 0; col < 4; ++col) { // Iterate over columns
            ListView_GetItemText(hListview, i, col, buffer, sizeof(buffer));
            // Sanitize text from newlines and carriage returns
            for (int j = 0; buffer[j] != '\0'; j++) {
                if (buffer[j] == '\n' || buffer[j] == '\r') {
                    buffer[j] = ' '; // Replace newline characters with space
                }
            }
            fprintf(file, "\"%s\"", buffer);
            if (col < 3) { // Add comma except for the last column
                fprintf(file, ",");
            } else {
                fprintf(file, "\n");
              }
          }
      }

    fclose(file);
    MessageBox(NULL, "ListView data exported to file successfully.", "Success", MB_OK | MB_ICONINFORMATION);
    }

//Read output generated by gpg line by line and get the string starting with GOODSIG or BADSIG.
char *filterLines(const char *text) {
    // Buffer to store each line read from the text
    char line[1024];
    const char *delim = "\n";

    // Allocate memory for the filtered lines
    char *filtered_lines = (char *)malloc(strlen(text) + 1);
    filtered_lines[0] = '\0'; // Initialize with an empty string

    // Tokenize the input text into lines
    char *token = strtok((char *)text, delim);
    while (token != NULL) {
        // Check if the line starts with "[GNUPG:] GOODSIG" or "[GNUPG:] BADSIG"
        if (strncmp(token, "[GNUPG:] GOODSIG", strlen("[GNUPG:] GOODSIG")) == 0 ||
            strncmp(token, "[GNUPG:] BADSIG", strlen("[GNUPG:] BADSIG")) == 0) {
            // Concatenate the line to the filtered lines string
            strncat(filtered_lines, token, 1024);
            strncat(filtered_lines, "\n", 1024);
        }
        // Get the next token
        token = strtok(NULL, delim);
    }

    return filtered_lines;
}

// Define a structure to hold the signature information
typedef struct {
    char sig_status[256];
    char sig_id[256];
    char sig_name[256];
} SignatureInfo;

// Function to parse the input string and return signature information as a structure
SignatureInfo parse_input_string(const char *input) {
    SignatureInfo info = {0}; // Initialize structure with zeros

    // Find the positions of first three spaces
    int space_positions[3] = {0};
    int count = 0;
    for (int i = 0; input[i]; i++) {
        if (input[i] == ' ') {
            space_positions[count] = i;
            count++;
            if (count == 3) break;
        }
    }

    // Check if the input string has at least three spaces
    if (count < 3) {
        strncpy(info.sig_status, "ERROR", 256);
        return info; // Return error status
    }

    // Split the string into parts
    strncpy(info.sig_status, input + space_positions[0] + 1, space_positions[1] - space_positions[0] - 1);
    info.sig_status[space_positions[1] - space_positions[0] - 1] = '\0';

    strncpy(info.sig_id, input + space_positions[1] + 1, space_positions[2] - space_positions[1] - 1);
    info.sig_id[space_positions[2] - space_positions[1] - 1] = '\0';

    strncpy(info.sig_name, input + space_positions[2] + 1, sizeof(info.sig_name) - 1);
    info.sig_name[sizeof(info.sig_name) - 1] = '\0'; // Ensure null termination

    return info;
}

    void openFiles(HWND hwndDlg, char *filenames[], int *numFiles) {
    OPENFILENAME ofn;
    char szFile[MAX_PATH * 1000] = "";
    ZeroMemory(&ofn, sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwndDlg;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = sizeof(szFile);
    ofn.lpstrFilter = "Signature Files (*.sig;*.gpg;*.pgp;*.asc)\0*.sig;*.gpg;*.pgp;*.asc\0";
    ofn.nFilterIndex = 1;
    ofn.Flags = OFN_ALLOWMULTISELECT | OFN_EXPLORER | OFN_FILEMUSTEXIST;
    ofn.lpstrDefExt = "";

    if (GetOpenFileName(&ofn) == TRUE) {
        char *directory = szFile;
        filenames[0] = directory;
        char *p = szFile + ofn.nFileOffset;


        // Check if more than 1000 files selected
        int fileCount = 0;
        while (*p) {
            fileCount++;
            p += strlen(p) + 1;
        }
        if (fileCount > 1000) {
            MessageBox(hwndDlg, "Too many files selected", "Error", MB_OK | MB_ICONERROR);
            *numFiles = 0;
            return;
        }

        // Reset pointer to the beginning of file list
        p = szFile + ofn.nFileOffset;


        char* ptr = ofn.lpstrFile;
        ptr[ofn.nFileOffset-1] = 0;
        int i = 1;
        while (*p) {
            char *filename = malloc(sizeof(char) * (strlen(directory) + strlen(p) + 2));
            snprintf(filename, sizeof(char) * (strlen(directory) + strlen(p) + 2), "%s\\%s", ptr, p);
            filenames[i] = filename;
            p += strlen(p) + 1;
            i++;
        }
    *numFiles = i;
    }
}

char* VerifySignature(char* SigFile)
{
    TCHAR Gpg_Import[MAX_PATH] = _T("gpg -quiet --import ");
    TCHAR Gpg_Verify[MAX_PATH] = _T("gpg --status-fd 1 --verify ");
    TCHAR DevPkey[MAX_PATH]=_T("");
    GetDlgItemText(hwndDlg,IDC_FILENAME_DEV_PK,DevPkey,MAX_PATH);
    TCHAR GpgImportJoined[2048];
    TCHAR GpgVerifyJoined[2048];
    snprintf(GpgImportJoined, sizeof GpgImportJoined, "%s\"%s\"", Gpg_Import, DevPkey);
    snprintf(GpgVerifyJoined, sizeof GpgVerifyJoined, "%s\"%s\"", Gpg_Verify, SigFile);

    SECURITY_ATTRIBUTES sa;
    sa.nLength = sizeof(sa);
    sa.bInheritHandle = TRUE;
    sa.lpSecurityDescriptor = NULL;

    HANDLE hRead, hWrite;
    if (!CreatePipe(&hRead, &hWrite, &sa, 0))
        return NULL;

    STARTUPINFOA si;
    PROCESS_INFORMATION pi;
    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    si.hStdError = hWrite;
    si.hStdOutput = hWrite;
    si.dwFlags |= STARTF_USESTDHANDLES;

    if (!CreateProcess(NULL, GpgImportJoined, NULL, NULL, TRUE, CREATE_NO_WINDOW, NULL, NULL, &si, &pi))
        return NULL;

    if (!CreateProcess(NULL, GpgVerifyJoined, NULL, NULL, TRUE, CREATE_NO_WINDOW, NULL, NULL, &si, &pi))
        return NULL;

    CloseHandle(hWrite);

    DWORD bytes;
    CHAR buffer[2048];
    DWORD currentPosition = 0;
    DWORD totalBytes = 0;
    CHAR* GpgOutput = NULL;

    while (ReadFile(hRead, buffer, 2048, &bytes, NULL) && bytes > 0)
    {
        totalBytes += bytes;
        GpgOutput = realloc(GpgOutput, totalBytes);
        if (GpgOutput == NULL)
        {
            // Handle allocation failure
            break;
        }
        memcpy_s(GpgOutput + currentPosition, totalBytes - currentPosition, buffer, bytes);
        currentPosition += bytes;
    }

    CloseHandle(hRead);
    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);

    char *FinalText = filterLines(GpgOutput);

    // Clean up dynamically allocated memory
    free(GpgOutput);

    return FinalText;
}


	switch(uMsg) {

		case WM_CLOSE:
			EndDialog(hwndDlg,1);
			break;


        case WM_NOTIFY: {
            NMHDR* nmhdr = (NMHDR*)lParam;
            if (nmhdr->code == NM_CUSTOMDRAW) {
                LPNMLVCUSTOMDRAW lplvcd = (LPNMLVCUSTOMDRAW)lParam;
                if (lplvcd->nmcd.dwDrawStage == CDDS_PREPAINT) {
                    // Request item-specific notifications for custom drawing
                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, CDRF_NOTIFYITEMDRAW);
                    return TRUE;
                } else if (lplvcd->nmcd.dwDrawStage == CDDS_ITEMPREPAINT) {
                    // Item-specific custom drawing
                    int itemIndex = (int)lplvcd->nmcd.dwItemSpec;
                    HWND hListview = GetDlgItem(hwndDlg, IDC_LISTVIEW);
                    LVITEM lvItem;
                    lvItem.mask = LVIF_TEXT;
                    lvItem.iItem = itemIndex;
                    lvItem.iSubItem = 1; // Assuming "Signatures" is in the second column
                    lvItem.pszText = ""; // Initialize pszText
                    char buffer[2048];
                    lvItem.cchTextMax = sizeof(buffer);
                    lvItem.pszText = buffer; // Assign buffer to pszText
                    ListView_GetItem(hListview, &lvItem);
                    if (strstr(lvItem.pszText, "GOODSIG") != NULL) {
                        // Change background color for items containing "GOODSIG"
                        lplvcd->clrTextBk = RGB(0, 255, 0); // Green background
                    }
                    else if (strstr(lvItem.pszText, "BADSIG") != NULL)
                    {
                        lplvcd->clrTextBk = RGB(255, 0, 0);
                    }
                    else
                    {
                        lplvcd->clrTextBk = RGB(255, 10, 0);
                    }
                    // Indicate that we've handled this item
                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, CDRF_NEWFONT);
                    return TRUE;
                }
            }
            break;
        }




        case WM_INITDIALOG:
			{
				// make sure the bright icon is on the window
				SendMessage(hwndDlg,WM_SETICON,ICON_SMALL,(LPARAM)LoadIcon(gInstance,MAKEINTRESOURCE(IDI_ICON1)));
				SetFocus(hwndDlg); // get up front
				HINSTANCE hInstance;

                HWND hListview = CreateWindow(WC_LISTVIEW, "", WS_CHILD | WS_VISIBLE | WS_BORDER | LVS_REPORT | LVS_SINGLESEL, 10, 120, 565, 200, hwndDlg, (HMENU)IDC_LISTVIEW, hInstance, NULL);

                LV_COLUMN lvcol;
                lvcol.mask = LVCF_TEXT | LVCF_WIDTH;
                lvcol.cx = 200;
                lvcol.pszText = "Filename";
                ListView_InsertColumn(hListview, 0, &lvcol);
                lvcol.cx = 150;
                lvcol.pszText = "Signature Status";
                ListView_InsertColumn(hListview, 1, &lvcol);
                lvcol.cx = 150;
                lvcol.pszText = "SigID";
                ListView_InsertColumn(hListview, 2, &lvcol);
                lvcol.cx = 200;
                lvcol.pszText = "Issuer";
                ListView_InsertColumn(hListview, 3, &lvcol);
                SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR)hListview);
			}
			return TRUE;


		case WM_COMMAND:
			switch(LOWORD(wParam)) {
				case IDOK:
					EndDialog(hwndDlg,1);
					break;

        case IDC_ABOUT: 

                {
                    MessageBox(hwndDlg, "GpgChecker 1.0.0\n(C)2024 IvanAegis", "About", MB_OK | MB_ICONINFORMATION);
                }

            break;

        case IDC_ADDFILES:

            {
                    warnIfFileNotPresent("gpg.exe");
                    TCHAR DevPkey[MAX_PATH]=_T("");
                    GetDlgItemText(hwndDlg,IDC_FILENAME_DEV_PK,DevPkey,MAX_PATH);
                    if (strncmp(DevPkey, "",MAX_PATH) == 0)
                    {
                    MessageBox(hwndDlg, "Developer public key is empty", "Error", MB_OK | MB_ICONERROR);
                    return 0;
                    }

                    HWND hListview = (HWND)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
                    char *filenames[1000];
                    int numFiles = 0;
                    openFiles(hwndDlg, filenames, &numFiles);

                    // Add items to the listview
                    int i;
                    for (i = 0; i < numFiles; i++) {
                    char *filename = filenames[i];
                    char *sigstatus=VerifySignature(filenames[i]);
                    char *sample= sigstatus;
                    SignatureInfo gpgstat = parse_input_string(sample);

                    // Add item to listview

                    LVITEM lvitem;
                    lvitem.mask = LVIF_TEXT;
                    lvitem.iItem = i-1;
                    lvitem.iSubItem = 0;
                    lvitem.pszText = filename;
                    ListView_InsertItem(hListview, &lvitem);
                    lvitem.iSubItem = 1;
                    lvitem.pszText = gpgstat.sig_status;
                    ListView_SetItem(hListview, &lvitem);
                    lvitem.iSubItem = 2;
                    lvitem.pszText = gpgstat.sig_id;
                    ListView_SetItem(hListview, &lvitem);
                    lvitem.iSubItem = 3;
                    lvitem.pszText = gpgstat.sig_name;
                    ListView_SetItem(hListview, &lvitem);

                    //UpdateWindow(hListview);
                    RedrawWindow(hListview, NULL, NULL, RDW_ERASE | RDW_FRAME | RDW_INVALIDATE | RDW_ALLCHILDREN);
                    }
            }
            break;

        //Clean listview list
        case IDC_FLUSH:
            {
            HWND hListview = (HWND)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
            ResetListView(hListview);
            }

            break;

        case IDC_EXPORT:
            {
            HWND hListview = (HWND)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
            TCHAR filename3[MAX_PATH]=_T("");
            TCHAR mask[]=_T("Comma Separated Values (*.csv;*.txt)\0*.csv;*.txt\0");
            OPENFILENAME open;

            ZeroMemory(&open,sizeof(OPENFILENAME));
            open.lStructSize  =(DWORD)sizeof(OPENFILENAME);
            open.lpstrFilter  =mask;
            open.nFilterIndex =0;
            open.lpstrFile    =filename3;
            open.nMaxFile     =MAX_PATH;
            open.Flags        =OFN_EXPLORER | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT;
            open.lpstrDefExt  =_T("");
            open.hwndOwner    =hwndDlg;
            open.hInstance    =gInstance;

              if(GetSaveFileName(&open))
                {
                ExportListViewToFile(hListview, filename3);
                }
            }

            break;

          case IDC_DEVFILE: //Get developer public key full file path

                {
          TCHAR filename2[MAX_PATH]=_T("");
					TCHAR mask[]=_T("Signature Files (*.sig;*.gpg;*.pgp;*.asc)\0*.sig;*.gpg;*.pgp;*.asc\0");
					OPENFILENAME open;

					ZeroMemory(&open,sizeof(OPENFILENAME));
					open.lStructSize  =(DWORD)sizeof(OPENFILENAME);
					open.lpstrFilter  =mask;
					open.nFilterIndex =0;
					open.lpstrFile    =filename2;
					open.nMaxFile     =MAX_PATH;
					open.Flags        =OFN_EXPLORER | OFN_FILEMUSTEXIST;
					open.lpstrDefExt  =_T("");
					open.hwndOwner    =hwndDlg;
					open.hInstance    =gInstance;

					if(GetOpenFileName(&open)) {
						SetDlgItemText(hwndDlg,IDC_FILENAME_DEV_PK,filename2);
					}
				}

			break;

            }

        }

    return FALSE;

};

int WINAPI WinMain(HINSTANCE hInstance,HINSTANCE hPrevInstance,LPSTR lpCmdLineA,int nCmdShow)
{
	gInstance=hInstance;
	InitCommonControls();
	return DialogBox(hInstance,MAKEINTRESOURCE(IDD_MAIN),0,(DLGPROC)MainDialogFunc);
};
